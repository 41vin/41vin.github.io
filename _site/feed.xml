<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-06-10T18:44:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Escape Diary</title><subtitle>From the master's program to the doctoral program, there were many moments during my time in post-graduate school when I wanted to escape. However, it seems to have been the most significant turning point in my life. Enjoy reading :)
</subtitle><author><name>Geon Kim</name><email>gun@khu.ac.kr</email></author><entry><title type="html">Forecasting at Scale</title><link href="http://localhost:4000/blog/paper/2024-06-10-Forecasting-at-Scale/" rel="alternate" type="text/html" title="Forecasting at Scale" /><published>2024-06-10T00:00:00+09:00</published><updated>2024-06-10T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/Forecasting-at-Scale</id><content type="html" xml:base="http://localhost:4000/blog/paper/2024-06-10-Forecasting-at-Scale/"><![CDATA[<p class="note" title="Keywords">Time Series, Statistical Practice, Nonlinear Regression</p>

<ul id="markdown-toc">
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a></li>
  <li><a href="#2-summary-of-paper" id="markdown-toc-2-summary-of-paper">2. Summary of paper</a>    <ul>
      <li><a href="#21-introduction" id="markdown-toc-21-introduction">2.1 Introduction</a></li>
      <li><a href="#22-features-of-business-time-seriers" id="markdown-toc-22-features-of-business-time-seriers">2.2 Features of Business Time Seriers</a></li>
      <li><a href="#23-the-prophet-forecasting-model" id="markdown-toc-23-the-prophet-forecasting-model">2.3 The Prophet Forecasting Model</a></li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take away</a></li>
</ul>

<h1 id="1-why-this-paper">1. Why this paper</h1>
<ul>
  <li>통계 기반 시계열 예측 알고리즘 조사</li>
  <li>SKT AI Fellowship 비교 알고리즘 개발에 필요</li>
</ul>

<h1 id="2-summary-of-paper">2. Summary of paper</h1>

<h2 id="21-introduction">2.1 Introduction</h2>

<ul>
  <li>비즈니스 단계에서 높은 수준의 시계열 예측이 어려운 이유
    <ol>
      <li>완전 자동화된 예측 기술들은 튜닝하기 어렵고, heuristic에 비해 유연하지 않음</li>
      <li>조직 내 데이터 전문가들이 시계열 예측에 대해 익숙하지 않을 수 있음</li>
    </ol>
  </li>
</ul>

<p class="note">규모에 상관없는 forecasting을 만들기 위한 유용한 가이드라인들을 제공하는 것이 목적임</p>

<p>본 논문에서는 큰 스케일의 시계열 트래픽을 예측하는 것이 상대적으로 간단하다고 한다. 병렬화가 매우 용이하며 예측 결과를 관계형 데이터베이스에 저장하는 것도 어렵지 않기 떄문이다. 진짜 큰 어려움은 <strong>예측 결과의 신뢰성</strong>이다.</p>

<p><img src="/assets/img/blog/prophet/prophet1.png" alt="Figure.1" /></p>

<ol>
  <li>각 parameter가 쉽게 이해될 수 있도록 유연한 방법으로 시계열을 모델링</li>
  <li>모델과 기준 모델에 대해 다양한 과거 데이터에 대한 예측을 생성 후, 성능 평가</li>
  <li>성능이 좋지 않을 경우, 우선순위를 정해 문제를 전문가에게 알림</li>
  <li>분석가가 이를 검토하고 피드백을 바탕으로 모델을 조정</li>
</ol>

<h2 id="22-features-of-business-time-seriers">2.2 Features of Business Time Seriers</h2>

<p><img src="/assets/img/blog/prophet/prophet2.png" alt="Figure.2" /></p>

<p class="note">위의 그림은 <strong>R</strong>의 <strong>forecasting</strong> 패키지를 이용해 다양한 알고리즘으로 예측을 수행한 것이다.</p>

<p>전체 시간 중 세개의 구역에서 예측을 수행하였으며, 각각의 예측은 시작 지점 전까지의 시계열 데이터만을 이용하여 해당 날짜에 예측을 수행하는 시뮬레이션을 한 것이다. 예측에는 아래의 알고리즘들이 사용되었다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">auto.arima</code>
    <ul>
      <li>ARIMA 모델 여러개 중 가장 성능이 좋은 모델을 고름</li>
      <li>Large trend error에 취약</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ets</code>
    <ul>
      <li>여러 개의 exponential 함moothing model 중 가장 은능이 좋은 모델을 고름</li>
      <li>주간 trend 데이터의 계절성은 잘 포착하지만, 장기간 trend 계절성은 잘 포착하지 못함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">snaive</code>
    <ul>
      <li>계절성을 가지는 데이터를 예측하는 데 사용되며, 매주 반복되는 패턴을 가진 데이터에 적합함</li>
      <li>주간 trend 데이터의 계절성은 잘 포착하지만, 장기간 trend 계절성은 잘 포착하지 못함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">tbats</code>
    <ul>
      <li>주간 혹은 연간 계절성을 가지는 데이터에 적합함</li>
    </ul>
  </li>
</ul>

<p class="note">예측이 잘못되었을 때 모델의 parameter들을 튜닝해야 하는데 이 과정에서 시계열 모델에 대한 깊은 이해가 필요함</p>

<h2 id="23-the-prophet-forecasting-model">2.3 The Prophet Forecasting Model</h2>

<p>Harvey &amp; Peters가 제안한 방법을 활용하여 시계열 데이터를 세가지 주요 컴포넌트로 분류하였다: trend, seasonality, and holidays. 아래의 식과 같이 나타낼 수 있다.</p>

\[y(t) = g(t) + s(t) + h(t) + \epsilon_{t}\]

<ul>
  <li>\(g(t)\) : 시계열 데이터에서 비주기적인 변화를 모델링하는 trend 함수</li>
  <li>\(s(t)\) : 주기적인 변화(e.g., weekly 혹은 yearly 계절성)를 나타냄</li>
  <li>\(h(t)\) : 하루 혹은 그 이상으로 불규칙적으로 스케쥴링 된 날들을 모델링하는 holiday 함수</li>
  <li>\(\epsilon_{t}\) : 모델에 캡쳐되지 않는 독특한 변화들, 후에 normally 분포되었다고 가정할 예정</li>
</ul>

<p>이러한 구조는 Hastie &amp; Tibshiran이 제안한 Generalized Additive Model(GAM)과 유사하다</p>

<blockquote>
  <p>Non-linear smoothers가 regressor에 적용된 regression model의 한 종류</p>
</blockquote>

<p>여기서는 시간만을 regressor로 사용하지만, 시간의 여러 선형 및 비선형 함수들을 구성 요소로 사용할 수 있다.</p>

<p>GAM 공식은 분해하기 쉽고 필수적으로 새로운 컴포넌트들을 포함한다는 장점이 있다. 또한 매우 빠르게 환경에 적응한다. 따라서 사용자들은 모델 parameter들을 이에 맞춰 변화시킬 수 있다.</p>

<p>본 논문의 저자들은 예측 문제를 <strong>curve-fitting exercise</strong>로 정의하였다. 이는 데이터의 시간 의존 구조를 고려하는 시계열 모델과 본질적으로 다르다.</p>

<p>ARIMA와 같은 생성 모델을 이용하면 얻을 수 있는 inferential 장점들을 포기해야 하지만 아래와 같은 practical한 장점들을 얻을 수 있다.</p>

<ul>
  <li>Flexibility:</li>
</ul>

<h1 id="3-take-away">3. Take away</h1>]]></content><author><name>Geon Kim</name><email>gun@khu.ac.kr</email></author><category term="paper" /><category term="tp" /><category term="stat" /><summary type="html"><![CDATA[**Authors**: Attai Ibrahim Abubakar, Hichael S. Mollel, Metin Ozturk, Sajjad Hussain, and Muhammad Ali Imran]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/prophet/prophet_logo.webp" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/prophet/prophet_logo.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">A Lightweight Cell Switching and Traffic Offloading Scheme for Energy Optimization in Ultra-Dense Heterogeneous Netweorks</title><link href="http://localhost:4000/blog/paper/2024-06-04-lightweight-cell-switching/" rel="alternate" type="text/html" title="A Lightweight Cell Switching and Traffic Offloading Scheme for Energy Optimization in Ultra-Dense Heterogeneous Netweorks" /><published>2024-06-04T00:00:00+09:00</published><updated>2024-06-04T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/lightweight-cell-switching</id><content type="html" xml:base="http://localhost:4000/blog/paper/2024-06-04-lightweight-cell-switching/"><![CDATA[<p class="note" title="Keywords">Cell-switching, HetNet, Traffic-offloading</p>

<ul id="markdown-toc">
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a></li>
  <li><a href="#2-summary-of-paper" id="markdown-toc-2-summary-of-paper">2. Summary of paper</a>    <ul>
      <li><a href="#21-introduction" id="markdown-toc-21-introduction">2.1 Introduction</a></li>
      <li><a href="#22-contributions" id="markdown-toc-22-contributions">2.2 Contributions</a></li>
      <li><a href="#23-system-model" id="markdown-toc-23-system-model">2.3 System Model</a>        <ul>
          <li><a href="#23a-network-model" id="markdown-toc-23a-network-model">2.3.A Network model</a></li>
          <li><a href="#23b-udhn의-소모-전력" id="markdown-toc-23b-udhn의-소모-전력">2.3.B UDHN의 소모 전력</a></li>
        </ul>
      </li>
      <li><a href="#24-problem-formulation" id="markdown-toc-24-problem-formulation">2.4 Problem Formulation</a></li>
      <li><a href="#25-proposed-cell-switching-scheme" id="markdown-toc-25-proposed-cell-switching-scheme">2.5 Proposed Cell Switching Scheme</a>        <ul>
          <li><a href="#25a-cell-clustering" id="markdown-toc-25a-cell-clustering">2.5.A Cell clustering</a></li>
          <li><a href="#25b-multi-level-clustering-based-cell-switching-scheme" id="markdown-toc-25b-multi-level-clustering-based-cell-switching-scheme">2.5.B Multi-level clustering based cell switching scheme</a></li>
          <li><a href="#25c-threshold-based-hybrid-cell-switching-scheme" id="markdown-toc-25c-threshold-based-hybrid-cell-switching-scheme">2.5.C Threshold-based Hybrid Cell Switching Scheme</a></li>
        </ul>
      </li>
      <li><a href="#26-performance-evaluation" id="markdown-toc-26-performance-evaluation">2.6 Performance Evaluation</a>        <ul>
          <li><a href="#26a-traffic-data-and-simulation-parameters" id="markdown-toc-26a-traffic-data-and-simulation-parameters">2.6.A Traffic data and simulation parameters</a></li>
          <li><a href="#26b-performance-metrics" id="markdown-toc-26b-performance-metrics">2.6.B Performance metrics</a></li>
          <li><a href="#26c-benchmarks" id="markdown-toc-26c-benchmarks">2.6.C Benchmarks</a></li>
          <li><a href="#26d-results-and-discussions" id="markdown-toc-26d-results-and-discussions">2.6.D Results and Discussions</a></li>
        </ul>
      </li>
      <li><a href="#27-conclusion" id="markdown-toc-27-conclusion">2.7 Conclusion</a></li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take Away</a></li>
</ul>

<h1 id="1-why-this-paper">1. Why this paper</h1>

<ul>
  <li>Cell switching에 쓰이는 가벼운 알고리즘 구상에 필요</li>
  <li>Milan 데이터셋을 이용한 논문</li>
</ul>

<h1 id="2-summary-of-paper">2. Summary of paper</h1>

<h2 id="21-introduction">2.1 Introduction</h2>

<p>UDN 환경에서 아래와 같은 다양한 방법들이 전력 소모 최적화를 위해 사용되어 왔다.</p>

<ul>
  <li>Antenna muting</li>
  <li>Cell zooming</li>
  <li>Power control</li>
  <li>Sectorization</li>
  <li>Dynamic cell switching operations</li>
</ul>

<p>이 중 가장 전력을 절감할 수 있고 보편적으로 연구되고 있는 분야는 dynamic cell switching이다. 또한, cell switching은 기존 아키텍쳐에 최소한의 변화를 통해 실현시킬 수 있기 때문에 구현이 쉽다는 장점이 있다.</p>

<p>Cell switching을 위해 다양한 머신러닝 기법들이 제안되고 있다.</p>

<ol>
  <li>지도학습(e.g., artificial neural networks (ANN))</li>
  <li>비지도학습(e.g., k-means)</li>
  <li>강화학습(e.g., deep and double-deep Q-learning)</li>
</ol>

<p><strong>머신러닝 기반 알고리즘</strong>은 뛰어난 generalization 능력을 가지고 있고 급변하는 네트워크 환경에 적응할 수 있지만, training process가 컴퓨팅 자원을 많이 소모하여 실시간 네트워크에 사용하기 힘든 단점을 가지고 있다.</p>

<p><strong>휴리스틱 기반 알고리즘</strong>은 구현하기 쉽지만 generalization 능력이 부족하고, 급변하는 네트워크 환경에 적응할 수 없다는 단점을 가지고 있다.</p>

<p>본 논문에서는 optimal cell switching 기법으로 <code class="language-plaintext highlighter-rouge">exhaustive search algorithm (ES)</code>를 제안한다. 완전탐색은 사용 가능한 모든 SBS 조합을 탐색하기 때문에 최적의 조합을 찾아낼 수 있다. 하지만 이 방법은 SBS의 수가 늘어나면 컴퓨팅 자원 소모가 급격하게 늘어난다는 치명적인 단점을 가지고 있다.</p>

<p><code class="language-plaintext highlighter-rouge">ES</code>를 보완하기 위해 대안 방법으로 생각해낸 것이 clustering을 이용해 탐색 공간을 줄이고 완전탐색을 하여 소모 시간을 줄이는 것이다. 본 논문에서는 이를 기반으로 만든 <code class="language-plaintext highlighter-rouge">Threshold-based Hybrid cEll swItching Scheme(THESIS)</code> 알고리즘을 제안한다.</p>

<h2 id="22-contributions">2.2 Contributions</h2>

<ol>
  <li><strong>THESIS</strong>, k-means + ES 알고리즘을 통해 UDHN에서의 에너지 최적화를 실현시킴. 제안 알고리즘은 computationally 효율적이고 optimal 솔루션에 가까운 결과를 냄. 또한, 대규모 네트워크 환경에도 적용 가능함.</li>
  <li>비교 알고리즘은 단순히 k-means만 사용</li>
  <li>\(CO_{2}\) 절감량도 측정</li>
  <li>제안 알고리즘과 비교 알고리즘의 엄밀한 비교를 통한 computational 효율성 검증</li>
  <li>실제 네트워크 데이터를 이용하여 알고리즘의 scalability와 성능을 검증</li>
</ol>

<h2 id="23-system-model">2.3 System Model</h2>

<h3 id="23a-network-model">2.3.A Network model</h3>

<p>여러 개의 macro cells(MCs)로 이루어진 UDHN(Ultra Dense Heterogeneous Netweork) 환경을 고려한다. 각각의 MBS는 각기 다른 capacity와 power consumption을 가지고 있는 SBS들을 포함하고 있다.</p>

<p>UDHN은 CDSA(Control and Data Separated Architecture)를 채택한다.</p>

<ul>
  <li>MBS: 제어 BS를 담당하며 SBS들을 낮은 data rate로 커버리지 내에서 서비스</li>
  <li>SBS: 데이터 BS를 담당하며 높은 데이터 트래픽이 필요한 서비스 담당</li>
</ul>

<p><strong>Vertical traffic offloading</strong>: SBS가 traffic load가 없거나 적을 때, MBS로 traffic을 offloading</p>

<p>본 논문에서 정의하는 <code class="language-plaintext highlighter-rouge">QoS</code>: cell switching이 일어난 후 서비스 가능한 총 트래픽 양</p>

<p><img src="/assets/img/blog/lightweight-cs/figure.1.png" alt="Figure.1" /></p>

<h3 id="23b-udhn의-소모-전력">2.3.B UDHN의 소모 전력</h3>

<p>BS의 power 소비는 다음과 같다.</p>

\[P_{BS}(\lambda, t) = P_{o} + \lambda_{t}\eta P_{tx}\]

<ul>
  <li>\(P_{o}\): constant circuit power 소모</li>
  <li>\(\lambda_{t}\): 순간적인 traffic 로드</li>
  <li>\(\eta\): 로드와 관련있는 power 소모 컴포넌트</li>
  <li>\(P_{tx}\): BS의 송신 전력</li>
</ul>

<p>이 때 \(P_{o}, \eta, P_{tx}\)는 <strong>SBS의 종류</strong>에 따라 다르다.</p>

<p>UDHN의 총 소모 전력 \(P_u\)는 다음과 같다.</p>

\[P_{u}(\lambda, t) = \sum_{i} \sum_{j} P_{BS_{i,j}}(\lambda, t)\]

<ul>
  <li>\(P_{BS_{i,j}}\): \(i\)번째 MC(Macro Cell)에 속해있는 \(j\)번째 BS의 소모 전력</li>
  <li>\(P_{BS_{i,1}}\): \(i\)번째 MC에 속해있는 MBS의 소모 전력</li>
</ul>

<h2 id="24-problem-formulation">2.4 Problem Formulation</h2>
<p>\(T\)는 \(L\)의 길이를 가지는 duration으로 나뉜다. 이 때 \(u=[1,2,...,K]\)와 같이 \(T\) 안에 있는 \(L\) 길이의 블록 순서를 나타낼 수 있다. \(K\)는 \(T\)안에 있는 블록의 수이다(\(K=T/L\)).</p>

<p class="note">UDHN이 SBS가 낮은 트래픽 load를 가질 때 전원을 끄는 시나리오를 고려한다.</p>

<p>본 논문의 목적은 각 time slot에서 최소한의 전력 소모를 실현시킬 수 있는 최적의 switching strategy를 결정하는 것이다.</p>

\[P_u(\lambda, \Gamma_{i,j}) = \sum_{u} \sum_{i} \sum_{j} [\Gamma_{i,j}P_{BS_{i,j}}(\lambda,t) + (1-\Gamma_{i,j})P^{s}_{BS_{i,j}}]\]

<ul>
  <li>\(P^{s}_{BS_{i,j}}\): BS가 sleep mode일 때 소모 전력</li>
  <li>\(\Gamma_{i,j}\): t일 때, \((i,j)^{th}\) BS의 off/on 상태 (On일 때 1, Off일 때 0)</li>
</ul>

<p>따라서 power optimization objective function은 다음과 같이 작성할 수 있다.</p>

\[\begin{align*}
\max_{\Gamma_{i,j}}\quad &amp; P_u(\lambda, \Gamma_{i,j}), \tag{5} \\
\text{s.t}\quad &amp; z = \lambda_{i,1} + \sum_{j=2}^m \lambda_{i,j} \Gamma_{i,j}, \tag{6} \\
&amp; \hat{\lambda}_{i,1} \leq \lambda_{i,1}^m, \tag{7} \\
&amp; \Gamma_{i,j} \in \{0, 1\}. \tag{8}
\end{align*}\]

<ul>
  <li>Constraint (6): UDHN에 의해 지원되는 traffic demand는 cell switching과 traffic offloading 이전/이후 동일
    <ul>
      <li>\(z:\) Cell switching 이전 UDHN에 의해 지원되는 전체 traffic demand</li>
    </ul>
  </li>
  <li>Constraint (7): SBS에 의해 offloading 되는 traffic 총량이 MBS의 maximum traffic demand를 넘을 수 없다.
    <ul>
      <li>\(\hat{\lambda}_{i,1}\): Traffic offloading 이후 MBS의 traffic load</li>
      <li>\(\lambda^{m}_{i,1}\): MBS가 최대로 수용할 수 있는 traffic demand</li>
    </ul>
  </li>
  <li>Constraint (8): SBS의 상태는 on/off 둘 중 하나여야 함</li>
</ul>

<h2 id="25-proposed-cell-switching-scheme">2.5 Proposed Cell Switching Scheme</h2>

<p>최적 알고리즘으로 소개된 ES는 네트워크 규모가 커지면 계산 자원 요구량이 커지기 때문에 적합하지 않다. 이를 해결하기 위해 본 논문에서는 THESIS(k-means clustering + ES) 알고리즘을 제안한다.</p>

<h3 id="25a-cell-clustering">2.5.A Cell clustering</h3>

<p><strong>Selection of optimal number of clusters (elbow method)</strong></p>

<p>클러스터링에서 가장 중요한 것 중 하나는 데이터셋을 나눌 클러스터의 수를 결정하는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">elbow method</code>를 사용하여 최적의 클러스터 수를 결정할 수 있다.  <code class="language-plaintext highlighter-rouge">elbow method</code>에서 최적의 클러스터 수는 SSE(Sum of the Squares Errors)의 합으로 결정된다.</p>

\[SSE = \sum^{N}_{k=1}\sum(X-c_{k})^2\]

<ul>
  <li>\(k\): 클러스터의 수</li>
  <li>\(X\): 클러스터 안에 있는 data 포인트</li>
  <li>\(c_k\): 특정 클러스터의 평균값(중앙값)</li>
</ul>

<p class="note">SSE 곡선이 평탄화되기 전, elbow 모양을 보일 때 k값을 사용한다</p>

<h3 id="25b-multi-level-clustering-based-cell-switching-scheme">2.5.B Multi-level clustering based cell switching scheme</h3>

<p>MLC(Multi-level clustering) 알고리즘은 MBS의 커버리지 내에서 clustering과 light traffic load 된 SBS들을 MBS로 offload 하는 과정을 반복하여 최적의 클러스터 구성을 찾아낸다.</p>

<p><img src="/assets/img/blog/lightweight-cs/figure.2.png" alt="figure.2" /></p>

<p>알고리즘의 단계를 정리하면 다음과 같다.</p>

<ol>
  <li><strong>Elbow 방법을 사용하여 최적의 클러스터 수 결정</strong>: 데이터 포인트들을 클러스터링 하여 각 클러스터의 변동성이 최소가 되는 클러스터의 수를 찾는다.</li>
  <li><strong>k-평균 알고리즘을 적용하여 SBS 클러스터링</strong>: 최적의 클러스터 수를 기반으로 각 SBS의 트래픽 부하에 따라 첫 번째 레벨 클러스터링을 수행한다.</li>
  <li><strong>클러스터별 총 트래픽 부하 계산 및 비교</strong>: 각 클러스터의 트래픽 부하를 계산하고 이를 MBS에서 사용 가능한 무선 자원과 비교하여 off 할 수 있는 클러스터 수를 결정한다.</li>
  <li><strong>선택된 클러스터의 트래픽을 MBS로 오프로딩 후 네트워크의 전력 소비 계산</strong>: 선택된 클러스터의 트래픽을 MBS로 오프로딩하고, 그 결과로 네트워크의 전력 소비를 계산한다.</li>
  <li><strong>클러스터 추가 분할</strong>: 남은 클러스터 중 MBS가 처리할 수 있는 최대 트래픽 수요를 초과하는 클러스터는 더 작은 클러스터로 추가 분할하여 이전 단계들을 반복한다. 이 과정은 하나의 SBS만이 남을 때 까지 또는 더 이상 처리할 SBS가 없을 때까지 반복한다.</li>
  <li><strong>최종적인 전력 소비 계산 및 순위 매기기</strong>: 모든 클러스터링과 트래픽 오프로딩 작업 후 UDHN의 전력 소비를 계산하고, 얻은 전력 소비 값들을 오름차순으로 순위를 매겨 가장 낮은 전력 소비를 보이는 구성을 최적의 클러스터로 선택한다</li>
</ol>

<h3 id="25c-threshold-based-hybrid-cell-switching-scheme">2.5.C Threshold-based Hybrid Cell Switching Scheme</h3>

<p>앞에서 설명한 MLC 알고리즘이 대규모 네트워크에 적용할 수 있더라도 ES 알고리즘에 비해 sub-optimal 한 결과를 내게 된다. 어떠한 sub-optimal 알고리즘도 결국 ES 알고리즘과 근사한 결과를 낼 수 밖에 없다는 점을 기억하자.</p>

<p>이를 보완하고자 본 논문에서는 THESIS 알고리즘을 제안한다.
<img src="/assets/img/blog/lightweight-cs/figure.3.png" alt="Figure.3" /></p>

<p>MLC 방법과 같이 최적의 클러스터 수를 결정하는데 elbow 방법이 사용된다. 그 다음 k-means 알고리즘을 사용하여 SBS의 트래픽 로드를 기반으로 한 첫번째 단계의 클러스터링이 수행된다. 그 후, threshold value(\(B_{th}\))보다 작은 SBS 수를 가지는 클러스터가 결정된다. 그 클러스터는 ES 알고리즘을 이용해 전원을 꺼야 할 SBS를 결정하고 네트워크의 소모 전력이 계산된다.</p>

<p>\(B_{th}\)보다 큰 수의 SBS를 가지는 클러스터는 다시 한번 k-means 알고리즘을 사용해 재 클러스터링하고 ES를 적용하여 꺼야 할 SBS 수를 결정하고 네트워크의 전력 소비를 계산한다. 마지막으로, 다양한 SBS 세트를 꺼서 얻은 UDHN의 전력 소비를 기준으로 순위를 매긴다. 가장 작은 전력 소비를 보이는 SBS 세트를 최적의 꺼야 할 SBS 세트로 선택한다.</p>

<p>MLC와 다르게 THESIS 알고리즘은 클러스터 내에서 전원을 꺼야할 SBS를 고른다. 이를 통해 THESIS는 SBS들의 타입들(capacity and power consumption profile)을 구분할 수 있다.</p>

<h2 id="26-performance-evaluation">2.6 Performance Evaluation</h2>
<p>본 논문에서는 하나의 Macro cell 만을 가지고 시뮬레이션을 진행하였으며, 이 결과의 scalability가 증명되었기 때문에 상관없다고 언급한다. 시뮬레이션에서 사용한 파라미터는 아래의 그림과 같다.</p>

<p><img src="/assets/img/blog/lightweight-cs/figure.4.png" alt="Figure.4" /></p>

<h3 id="26a-traffic-data-and-simulation-parameters">2.6.A Traffic data and simulation parameters</h3>
<p>UDHN의 전체 전력을 계산하기 위해서는 MBS와 SBS들의 traffic load가 필요하다.</p>

<p>Milan 데이터셋의 inter activity level을 BS의 traffic load로 고려하였다. 임의로 선택한 두 개의 그리드를 결합하여 MBS의 트래픽 부하로 나타냈고, SBS의 경우 단일 그리드로 고려하였다. 그 후, 트래픽 부하는 UDHN의 각 SBS의 무선 자원 양에 따라 정규화 되었다.</p>

<h3 id="26b-performance-metrics">2.6.B Performance metrics</h3>
<ul>
  <li><strong>Power Consumpiton</strong>: UDHN 시뮬레이션 도중 소비한 instantaneous 소모 전력</li>
  <li><strong>Energy Saved</strong>: 24시간 동안 절감된 에너지 양을 측정</li>
  <li><strong>Carbon Emission</strong>: \(\mathcal{E}_{CO_2} = \zeta\sum_{t=1}^{T}E_{u,t}\) (\(\zeta\): \(CO_2\) conversion factor)</li>
  <li><strong>Average Network Throughput</strong>: Active BS들에 의해 서비스될 수 있는 총 네트워크 demand, \(\mathcal{T}_{N}(t) = \mathcal{T}_{i,1}(t) + \sum_{j=2} \mathcal{T}_{i,j}(t)\)</li>
</ul>

<h3 id="26c-benchmarks">2.6.C Benchmarks</h3>

<ul>
  <li><strong>ES</strong>: 항상 최적의 switching 패턴을 보장. 다른 cell switching 알고리즘의 목적은 이 알고리즘의 근삿값을 달성하는 것이다.</li>
  <li><strong>MLC</strong>: ES에 비해 computation overhead가 적다. QoS를 보장하며 네트워크 규모가 클 때도 사용할 수 있지만 ES 방식에 비해 sub-optimal한 성능을 보인다.</li>
  <li><strong>AAO</strong>: SBS들을 항상 켜 놓는 것으로, 네트워크 QoS를 보장하지만 에너지 절약 보장을 하지 못한다.</li>
</ul>

<p>Q-learning과 같은 강화학습 기반 알고리즘들이 decision making으로 유명하지만 실제 상황에서는 모델 학습이 어렵고 무겁기 때문에 벤치마크 알고리즘에서 제외하였다.</p>

<h3 id="26d-results-and-discussions">2.6.D Results and Discussions</h3>

<p><img src="/assets/img/blog/lightweight-cs/figure.5.png" alt="Figure.5" /></p>

<p>Traffic load의 양이 적을 때 small cell switching의 횟수가 많아지므로 traffic demand가 많을 때 소비 전력이 높고 traffic demand가 적을 때 소비 전력이 작게 된다.</p>

<p>ES 알고리즘을 사용했을 때 모든 경우의 수를 탐색하고 결과를 도출하기 때문에 가장 적은 전력을 소모하게 된다. 하지만 이 방법은 큰 컴퓨팅 소모를 하게 된다.</p>

<p>본 논문에서 제안한 THESIS 알고리즘이 네트워크의 traffic이 높을 때 0.4% 정도의 차이를 보이고, traffic이 낮을 때는 3.5%의 차이를 보임을 확인할 수 있다.</p>

<ul>
  <li>트래픽이 높을 때는 cell을 끌 필요가 많이 없고, 트래픽이 낮을 때 cell을 끌 기회가 많기 때문에 이러한 차이를 보인다.</li>
  <li>트래픽이 높을 때 THESIS와 ES 알고리즘이 거의 비슷한 결과를 보이는 것으로 보아 트래픽이 높을 때는 ES 알고리즘의 high search space라는 장점은 퇴색된다.</li>
</ul>

<p>그림 2(b)에서 ES 알고리즘은 사용되지 않았다. 컴퓨팅 오버헤드가 너무 커서 계산할 수가 없었기 때문이다.</p>

<p><img src="/assets/img/blog/lightweight-cs/figure.6.png" alt="Figure.6" /></p>

<p>최종적으로 위의 그래프에서 각 알고리즘 별 탄소 절감량을 확인할 수 있다. SBS 수가 늘어날수록 탄소 절감량도 늘어나게 되는데, SBS를 끌 수 있는 기회가 많아지기 떄문이다.</p>

<p><img src="/assets/img/blog/lightweight-cs/figure.7.png" alt="Figure.7" /></p>

<p>위의 그래프에서 각 알고리즘의 시간 복잡도를 확인할 수 있다. ES 알고리즘은 SBS의 수가 20개가 넘어가면 기하급수적으로 시간 복잡도가 증가하고, THESIS도 증가하는 추세를 보인다. 하지만 THESIS 알고리즘은 클러스터 내 SBS의 수를 \(B_{th}\)로 제한을 두기 때문에 시간복잡도가 기하급수적으로 증가하는 것을 막을 수 있다.</p>

<h2 id="27-conclusion">2.7 Conclusion</h2>

<p>위에서 볼 수 있듯이 본 논문에서 제안한 THESIS 알고리즘은 획기적인 에너지 절감을 실현시킬 수 있다. 또한 AAO 알고리즘에 비해 탄소 절감을 늘릴 수 있다는 장점도 존재한다. 본 논문의 저자는 future work로 UAV-BS를 이용한 traffic offloading을 제안하였다.</p>

<h1 id="3-take-away">3. Take Away</h1>

<ul>
  <li>Clustering + heuristic 알고리즘을 이용한 lightweight cell switching</li>
  <li>SBS 두 개를 합쳐 MBS로 가정하는 방법으로 HetNet 시뮬레이션</li>
</ul>]]></content><author><name>Geon Kim</name><email>gun@khu.ac.kr</email></author><category term="paper" /><category term="es" /><summary type="html"><![CDATA[**Authors**: Attai Ibrahim Abubakar, Hichael S. Mollel, Metin Ozturk, Sajjad Hussain, and Muhammad Ali Imran]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/lightweight-cs/es.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/lightweight-cs/es.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">OpenRAN Gym- AI/ML Development, Data Collection, and Testing for O-RAN on PAWR Platforms</title><link href="http://localhost:4000/blog/paper/2024-05-28-OpenRAN-Gym/" rel="alternate" type="text/html" title="OpenRAN Gym- AI/ML Development, Data Collection, and Testing for O-RAN on PAWR Platforms" /><published>2024-05-28T00:00:00+09:00</published><updated>2024-05-28T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/OpenRAN-Gym</id><content type="html" xml:base="http://localhost:4000/blog/paper/2024-05-28-OpenRAN-Gym/"><![CDATA[<p class="note" title="Keywords">Open RAN, AI/ML, SDK</p>

<ul id="markdown-toc">
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a></li>
  <li><a href="#2-summary-of-paper" id="markdown-toc-2-summary-of-paper">2. Summary of paper</a>    <ul>
      <li><a href="#21-introduction" id="markdown-toc-21-introduction">2.1 Introduction</a></li>
      <li><a href="#22-openran-gym" id="markdown-toc-22-openran-gym">2.2 OpenRAN Gym</a>        <ul>
          <li><a href="#221-주요-구성요소" id="markdown-toc-221-주요-구성요소">2.2.1 주요 구성요소</a></li>
        </ul>
      </li>
      <li><a href="#23-data-collection-and-control-framework" id="markdown-toc-23-data-collection-and-control-framework">2.3. DATA Collection and Control Framework</a>        <ul>
          <li><a href="#23a-starting-scope" id="markdown-toc-23a-starting-scope">2.3.A <em>Starting SCOPE</em></a></li>
        </ul>
      </li>
      <li><a href="#24-o-ran-control-architecture" id="markdown-toc-24-o-ran-control-architecture">2.4 O-RAN Control Architecture</a>        <ul>
          <li><a href="#24a-starting-the-colo-ran-near-rt-ric" id="markdown-toc-24a-starting-the-colo-ran-near-rt-ric">2.4.A Starting the ColO-RAN Near-RT RIC</a></li>
          <li><a href="#24b-connecting-the-scope-base-station-to-colo-ran" id="markdown-toc-24b-connecting-the-scope-base-station-to-colo-ran">2.4.B Connecting the SCOPE Base Station to ColO-RAN</a></li>
          <li><a href="#24c-initializing-a-sample-xapp" id="markdown-toc-24c-initializing-a-sample-xapp">2.4.C Initializing a Sample xApp</a></li>
        </ul>
      </li>
      <li><a href="#25-xapp-development-workflow-on-colosseum" id="markdown-toc-25-xapp-development-workflow-on-colosseum">2.5 xApp Development Workflow on Colosseum</a>        <ul>
          <li><a href="#25a-example-of-xapps" id="markdown-toc-25a-example-of-xapps">2.5.A Example of xApps</a></li>
        </ul>
      </li>
      <li><a href="#26-traveling-containers" id="markdown-toc-26-traveling-containers">2.6 Traveling Containers</a></li>
      <li><a href="#27-experimental-results" id="markdown-toc-27-experimental-results">2.7 Experimental Results</a>        <ul>
          <li><a href="#27a-results" id="markdown-toc-27a-results">2.7.A Results</a></li>
        </ul>
      </li>
      <li><a href="#28-conclusions" id="markdown-toc-28-conclusions">2.8 Conclusions</a></li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take Away</a></li>
</ul>

<h1 id="1-why-this-paper">1. Why this paper</h1>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MaveRIC</code> 시뮬레이터에 쓰일 알고리즘 공부</li>
  <li>RIC에 쓰일 알고리즘 구상에 필요한 프로그램</li>
</ul>

<h1 id="2-summary-of-paper">2. Summary of paper</h1>

<h2 id="21-introduction">2.1 Introduction</h2>
<p><code class="language-plaintext highlighter-rouge">Open RAN</code>은 네트워크 운영자들이 하드웨어 인프라를 교체하지 않고 네트워크 컨디션과 사용자의 요구에 맞춰 맞춤형 서비스를 제공할 수 있게 한다. 또한 하드웨어 교체가 필요없기 때문에 Operational cost를 효과적으로 감소시킬 수 있다.</p>

<p class="note" title="Attention">O-RAN Alliance는 Open RAN을 O-RAN으로 브랜딩하여 표준을 개발중이다.</p>

<p>O-RAN은 두 개의 RAN Intelligent Controller들을 제안하였다.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">near-RT RIC</code>
    <ul>
      <li>RAN 구성요소들(CUs, DUs)들과 <code class="language-plaintext highlighter-rouge">E2</code> 인터페이스로 연결되어 있으며 10ms와 1s 사이에서 작동하는 control loop들을 담당한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">non-RT RIC</code>
    <ul>
      <li>Service Management and Orchestration(SMO) 프레임워크들을 포함하고 있으며 1s보다 큰 시간 스케일에서 작동한다.</li>
      <li>하나 혹은 여러개의 near-RT RIC들과 <code class="language-plaintext highlighter-rouge">A1</code> 인터페이스를 통해 연결되어 있으며 이를 통해 policy들과 네트워크 외부 정보들을 전파시킨다.</li>
      <li>RIC 위에 올라가는 AI/ML 모델을 관리한다.</li>
    </ul>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">SMO</code>는 RAN과 <code class="language-plaintext highlighter-rouge">O1</code> 인터페이스를 통해 연결되며 management와 orchestration을 한다. 또한, virtualization platform(<code class="language-plaintext highlighter-rouge">O-cloud</code>)과 <code class="language-plaintext highlighter-rouge">O2</code> 인터페이스를 통해 연결되어 있다.</p>

<p>AI/ML 알고리즘들을 test/design 하는 것은 다음과 같은 단계들을 포함한다.</p>

<ol>
  <li><strong>Data collection</strong>: AI/ML 모델의 배포될 상황과 다양한 네트워크의 performance indicatos에 맞춰 practical한 dataset을 수집</li>
  <li><strong>AI/ML model design</strong>: 모델의 입/출력을 결정하고, training과 teseting을 결정 후, 성능 평가</li>
  <li><strong>Model deployment</strong>: xApp은 near-RT RIC에 rApp은 non-rt-RIC에 배포</li>
  <li><strong>Model fine-tuning</strong>: RAN의 런타임 데이터에 맞춰 모델을 서로 다른 프로덕션 환경에 적응시킴</li>
  <li><strong>Control, inference and/or forecasting</strong>: RAN을 AI/ML을 통해 제어</li>
</ol>

<p class="note">본 논문에서는 <strong>OpenRAN Gym</strong>(O-RAN 규격을 준수하는 inference와 control AI/ML 알고리즘을 개발하기 위한 오픈소스 toolbox)을 제시하고 있다.</p>

<p>저자는 가장 먼저 OpenRAN Gym의 high-level overview를 제공하고 그 구성요소가 어떻게 data-driven xApp들의 개발, 테스트 workflow들을 실현시키는지 논의한다.</p>

<p>OpenRAN Gym은 end-to-end 디자인, prototyping, testing, 그리고 HetNet 구조에서 실험된 최초의 오픈된, portable한 툴셋이다.</p>

<p><strong>OpenRAN Gym의 contribution</strong>: O-RAN ecosystem에서 AI/ML 솔루션들의 end-to-end 디자인과 테스트를 가능케함</p>

<hr />

<h2 id="22-openran-gym">2.2 OpenRAN Gym</h2>

<h3 id="221-주요-구성요소">2.2.1 주요 구성요소</h3>
<ol>
  <li>공식적, 원격으로 접속 가능한 HetNet 환경에서의 <em>experimental wireless platforms</em>, <code class="language-plaintext highlighter-rouge">Colosseum</code></li>
  <li>Open 프로토콜 스택으로 구현된 <em>softwarized</em> RAN, <code class="language-plaintext highlighter-rouge">srsRAN</code>, <code class="language-plaintext highlighter-rouge">OAI</code></li>
  <li><em>Data collection and control framework</em>, <code class="language-plaintext highlighter-rouge">SCOPE</code></li>
  <li><em>O-RAN control architecture</em>, <code class="language-plaintext highlighter-rouge">ColO-RAN</code></li>
</ol>

<ul>
  <li>Colosseum
    <ul>
      <li>세계에서 가장 큰 네트워크 에뮬레이터. 연구자와 기술자들이 거대한 스케일의 환경에서 연구를 진행할 수 있게 한다.</li>
    </ul>
  </li>
  <li>POWDER
    <ul>
      <li>Salt Lake City에 있는 도시 규모의 wireless tesetbed</li>
    </ul>
  </li>
  <li>COSMOS
    <ul>
      <li>New York City에 있는 도시 규모의 wireless testbed. mmWave 통신과 edge-computing을 중점으로 구현하였다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/blog/OpenRANgym/article/Figure.1.png" alt="Figure 1. OpenRAN Gym architecture" /></p>

<p>글이 작성된 시점에 OpenRAN Gym은 srsRAN을 이용해 softwarized RAN을 구성하였다. 또한, cellular protocol stack은 SCOPE 프레임워크에 의해 지원되었다. SCOPE를 사용하여 HetNet 환경에서의 데이터 수집을 자동화할 수 있다.</p>

<p>최종적으로, ColO-RAN을 사용해 O-RAN control architecture를 구현하였다. ColO-RAN은 사용자들이 AI/ML 기반 어플리케이션들을 xApp SDK를 사용해 prototype 할 수 있게 한다.</p>

<hr />

<h2 id="23-data-collection-and-control-framework">2.3. DATA Collection and Control Framework</h2>

<p class="note">OpenRAN Gym의 데이터 수집과 control 프레임워크는 SCOPE에 기반한다.</p>

<p>RAN의 런타임에 fine-tune과 데이터 수집을 담당하는 Open API들은 SCOPE에 의해 제공된다.
SCOPE는 실제 실행되고 있는 HetNet 실험환경에서 RAN KPM들을 수집하는 과정을 촉진시킬 수 있다. 결과적으로, SCOPE는 OSC DU에 있는 O-RAN E2 termination을 O-RAN near-RT RIC과 연결해준다.</p>

<h3 id="23a-starting-scope">2.3.A <em>Starting SCOPE</em></h3>
<p>SCOPE는 configuration 파일을 통해 cellular base station들을 작동할 수 있는 Command-line Interface (CLI) tool들을 지원한다.OpenRAN Gym에서 사용하는 주요 파라미터들은 다음과 같다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">network-slicing</code>: base station에서 network slicing을 가능하게 함</li>
  <li><code class="language-plaintext highlighter-rouge">slice-allocation</code>: network slicing이 가능하다면, Resource Block Groups(RBGs)를 세팅하는 파라미터
    <ul>
      <li><strong>예시</strong>: {0:[0, 5], 1:[6, 10]}의 뜻은 RBG 0-5는 slice 0에 6-10은 slice 1에 할당</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">slice-scheduling-policy</code>: 기지국의 network slice에 scheduling policy를 세팅
    <ul>
      <li><strong>예시</strong>: [1, 2]: slice 0에 slicing policy 1울 헐덩, slice 1에 policy 2를 할당(0: round-robin, 1: waterfilling, 2:proportionally fair)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">slice-users</code>: UE들을 특정 network slice에 associate 시킴.
    <ul>
      <li><strong>예시</strong>: {0:[4, 5], 1:[2, 3]}, UE 4,5를 slice 0, UE 2,3을 slice 1에 associate</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">generic-testbed</code>: SCOPE가 Colloseum 이외의 테스트베드에서 실행되고 있는지 여부를 나타냄</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SCOPE</code> 구성 파일이 JSON 형식 파일(<em>radio.conf</em>)로 작성된 후 cellular base station, core 네트워크, UE 어플리케이션들은 아래의 커맨드를 통해 시작된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># !/bin/bash</span>
<span class="nb">cd </span>radio_api/
python3 scope_start.py <span class="nt">--config-file</span> radio.conf
</code></pre></div></div>

<p>런타임 중 RAN으로부터 온 Relevang KPM들은 자동적으로 SCOPE base station들에 로깅된다. KPM 파일들은 CSV 형식으로 저장되고, on-the-fly로도 사용될 수 있다.(AI/ML 모델 훈련). 또한 experiment가 끝나고 offline으로도 회수되어 사용할 수 있다.</p>

<h2 id="24-o-ran-control-architecture">2.4 O-RAN Control Architecture</h2>
<p>OpenRAN GYM에서 사용하는 O-RAN control architecture는 ColO-RAN에 기반한다. 이 프레임워크는 OSC near-RT RIC의 lightweight 구현을 제공한다. Colosseum 시스템에서 standalone Docker 컨테이너로 구현되기 때문이다.</p>

<p>ColO-RAN의 high level 다이어그램은 아래의 그림과 같다. 
<img src="/assets/img/blog/OpenRANgym/article/Figure.2.png" alt="Figure 2. ColO-RAN xApp" /></p>

<p>ColO-RAN xApp은 두개의 주 구성요소로 이루어져있다,</p>

<ul>
  <li><em>Service Model(SM) Connector</em>: xApp과 near-RT RIC 사이의 메세지들을 관리</li>
  <li><em>Data-driven logic unit</em>: RAN base station들로부터 받은 KPM들은 처리하고 AI/ML 모델들로부터 받은 과제 수행
    <ul>
      <li><strong>AI/ML model</strong>: 특정 data-driven model로 구성(예, DRL agent, DNN 등)</li>
      <li><strong>Data processing module</strong>: KPM 데이터들을 AI/ML 모델이 사용할 수 있는 데이터 형식으로 변환</li>
    </ul>
  </li>
</ul>

<h3 id="24a-starting-the-colo-ran-near-rt-ric">2.4.A Starting the ColO-RAN Near-RT RIC</h3>
<p>ColO-RAN의 near-RT RIC은 <code class="language-plaintext highlighter-rouge">setup-ric.sh</code>를 이용하여 docker 컨테이너로 빌드될 수 있다. 이 스크립트를 이용해 RIC은 RAN으로부터 메세지를 받고 교환할 수 있다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cd </span>setup-scripts/
./setup-ric.sh col0
</code></pre></div></div>

<p>ColO-RAN near-RT RIC의 이미지들은 다음과 같은 항목들을 포함한다.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">e2term</code>: RIC E2 메세지의 종단점</li>
  <li><code class="language-plaintext highlighter-rouge">e2mgr</code>: E2 인터페이스로 송/수신되는 메시지들을 관리</li>
  <li><code class="language-plaintext highlighter-rouge">e2rtmansim</code>: RIC 안에서 RIC Message Router(RMR) 프로토콜을 사용하여 E2 메시지들을 라우팅</li>
  <li><code class="language-plaintext highlighter-rouge">db</code>: Redis 데이터베이스를 이용해 RIC에 연결된 RAN 노드들의 기록을 저장</li>
</ol>

<p>Docker 이미지 빌드 후, E2 termination 종단점을 통해 다가올 연결을 listening하는 RIC 컨테이너들이 생성된다.</p>

<h3 id="24b-connecting-the-scope-base-station-to-colo-ran">2.4.B Connecting the SCOPE Base Station to ColO-RAN</h3>

<p>위의 과정을 통해 ColO-RAN이 세팅되고 시작된 후, cellular base station은 O-RAN E2 termination을 통해 연결될 수 있다. RAN-side E2 termination은 아래의 목적들로 사용될 수 있는데</p>
<ol>
  <li>xApp들로부터 <em>RIC Subscription</em> 수신</li>
  <li><em>RIC Indication</em> 메세지를 통해 xApp들에게 주기적으로 KPM reports를 송신</li>
  <li>xApp들로부터 받은 control message들에 기반해 base station들의 런타임 동안 configuration을 수정</li>
</ol>

<p>SCOPE base station의 E2 termination을 초기화하는 커맨드는 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cd </span>colosseum-scope-e2/
./build_odu.sh clean
./run_odu.sh
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">build_odu.sh</code>: near-RT RIC이 연결할 IP 주소와 포트를 특정</li>
  <li><code class="language-plaintext highlighter-rouge">run_odu.sh</code>: E2 termination 프로세스 실행, base station과 near-RT RIC 연결</li>
</ul>

<p>연결이 성공적으로 수행되었다면 <code class="language-plaintext highlighter-rouge">docker logs -f e2term</code> 커맨드를 통해 확인할 수 있다.</p>

<h3 id="24c-initializing-a-sample-xapp">2.4.C Initializing a Sample xApp</h3>

<p>SCOPE base station이 near-RT RIC에 연결된 후, xApp들은 시작될 수 있다. 본 논문에서는 xApp 디자인을 장려하기 위해 <code class="language-plaintext highlighter-rouge">ready-to-use sample xApp</code> 템플릿을 제공하고 있다. 이 템플릿에 연구자들은 AI/ML 모델을 plug-in 하기만 하면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cd </span>setup-scripts/
./setup-sample-xapp.sh gnb:&lt;example&gt;
</code></pre></div></div>

<p>xApp이 구독해야하는 base station의 식별자를 커맨드에 입력한다. 그 후 sample xApp의 Docker 이미지를 빌드한다. 스크립트는 near-RT RIC에서 sample-xApp이라는 xApp Docker 컨테이너를 시작한다.</p>

<p>컨테이너 시작 후, xApp 프로세스들은 아래의 커맨드들을 통해 실행된다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> sample-xapp /home/sample-xapp/run_xapp.sh
</code></pre></div></div>

<p>위의 커맨드는 targeted RAN 노드들에 RIC Subscription 메시지, 주기적인 RAN KPMs reports를 통해 xApp subscription을 유발한다.</p>

<h2 id="25-xapp-development-workflow-on-colosseum">2.5 xApp Development Workflow on Colosseum</h2>

<p>Open RAN Gym on Colosseum을 사용해 Data-driven xApp을 개발하는 과정은 아래의 그림과 같이 나타낼 수 있다.</p>

<p><img src="/assets/img/blog/OpenRANgym/article/Figure.3.png" alt="OpenRAN Gym xApp Design and testing workflow on Colosseum" /></p>

<ol>
  <li>
    <p><strong>Data collection</strong></p>

    <p>xApp에 임베드 되어있는 AI/ML 모델을 train/test하기 위한 데이터 수집</p>
  </li>
  <li>
    <p><strong>Model design, training and testing</strong></p>

    <p>AI/ML 모델이 사용할 알고리즘 선택, input으로 사용할 데이터 선택, output 액션들의 집합 설정을 포함한다. 디자인 phase 이후, offline으로 모델은 학습되고 테스트된다.</p>
  </li>
  <li>
    <p><strong>Deploy the model as an xApp</strong></p>

    <p>모델 test 후, ColO-RAN near-RT RIC의 xApp으로 배포된다. 정확하게는 AI/ML 모델은 ColO-RAN xApp의 <em>data-driven logic unit</em>에 포함된다.</p>
  </li>
  <li>
    <p><strong>Online model fine-tuning</strong></p>

    <p class="note">런타임 중, xApp은 near-RT RIC과 E2 termination을 이용하여 SCOPE base station과 통신한다.</p>

    <p>이를 달성하기 위해 다음과 같은 과정을 거친다.</p>
    <ol>
      <li>xApp은 RIC Subscription 메세지를 보내 base station을 subscribe 한다.</li>
      <li>주기적인 KPMs reports를 trigger 한다.</li>
      <li>Reports는 RIC Indication 메세지를 통해 전송되고, xApp에서 model을 online으로 fine-tune 하기 위해 사용된다.</li>
    </ol>
  </li>
  <li>
    <p><strong>Perform RAN control/inference</strong></p>

    <p>이 단계에서 xApp은 RAN에 inference와 control을 실행하는 live 인프라로 사용된다. xApp은 model에 의해 계산된 action을 SCOPE base station에게 RIC Control messages를 통해 전송한다.</p>
  </li>
</ol>

<h3 id="25a-example-of-xapps">2.5.A Example of xApps</h3>

<p>본 논문에서 제시하고 있는 xApp들은 Colosseum 네트워크 emulator 환경에서 7개의 base station과 42개의 UE들을 사용한 것이다. 각각의 base station들은 SCOPE를 통해 구현되었고, 6개의 UE를 서비스하고 있으며 UE들은 다른 traffic 요구조건을 가지고 있다.</p>

<p>UE들의 트래픽은 두 가지 종류로 나뉜다.</p>
<ol>
  <li>Time-sensitive(URLLC)</li>
  <li>Broadband(eMBB, MTC)</li>
</ol>

<p><img src="/assets/img/blog/OpenRANgym/article/Figure.4.png" alt="Figure 4" /></p>

<p>위의 그림은 본 논문에서 사용한 xApp의 구조이다.</p>

<ul>
  <li><strong>Data-driven logic unit</strong>
    <ul>
      <li><strong>Encoder</strong>: 데이터의 차원을 줄이는 역할, E2 인터페이스로 KPM reports를 수신</li>
      <li><strong>DRL agent</strong>: 수신받은 정보를 네트워크 상태로 바꾸고 최적화 하는 역할</li>
    </ul>
  </li>
</ul>

<ol>
  <li>
    <p><strong>Agent Design</strong></p>

    <p>DRL Agent는 Actor-critic 기반 구조의 <em>Proximal Policy Optimization(PPO)</em>로 구현된다. Actor와 Critic 모두 5 layer로 구성되며, 각 layer는 30개의 neuron을 가지고 있다.</p>
  </li>
  <li>
    <p><strong>Actions</strong></p>

    <p>본 논문에서는 서로 다른 두가지 xApp을 훈련시켜 네트워크 최적화 성능을 비교하였다.</p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sched</code>: 스케쥴링 정책(round robin, waterfall 등(만 제어</li>
      <li><code class="language-plaintext highlighter-rouge">sched-slicing</code>: 스케쥴링 정책 뿐 아니라 각 slice에 할당되는 자원들도 제어</li>
    </ul>
  </li>
  <li>
    <p><strong>Reward</strong></p>

    <p>두 xApp 모두 broadband traffic 클래스에서 전송되는 데이터를 최대화하고, time-sensitive traffic 클래스에선 end-to-end latency를 최소화하는 것을 목적으로 하였다.
 기지국의 데이터에서 직접적으로 end-to-end system latency를 명시하는 항목이 존재하지 않으므로 buffer occupancy 수치를 latency 기준으로 삼았다.</p>
    <ul>
      <li>Buffer occupancy: 각 패킷이 전송 buffer 큐에서 얼마나 시간을 보내는지 측정</li>
    </ul>

    <p>위에서 언급한 기준들을 reward에 반영하기 위해, throughput 최대화와 downlink buffer size를 최소화하는 것이 reward 함수에 반영되어 있다.</p>
  </li>
</ol>

<p><img src="/assets/img/blog/OpenRANgym/article/Figure.5.png" alt="Figure 5" /></p>

<p><code class="language-plaintext highlighter-rouge">sched-slicing</code> xApp이 더 좋은 성능을 보임을 그래프에서 확인할 수 있다.</p>

<h2 id="26-traveling-containers">2.6 Traveling Containers</h2>

<p>본 섹션에서는 컨테이너화 된 OpenRAN Gym이 어떻게 다른 testbed로 전송되는지 설명한다.<em>traveling OpenRAN Gym containers</em>의 구현 때문에 상당한 노력이 들었다고 한다.</p>

<p>후속 연구자들의 수고를 줄이기 위해 저자는 OpenRAN Gym LXC 컨테이너들을 개발하였다. 실행하고자 하는 testbed에서 LXC 이미지가 전송된 후, 아래의 커맨드를 입력하여 이미지가 import 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Listing 6</span>
lxc image import scope-with-e2.tar.gz <span class="nt">--alias</span> scope-e2
</code></pre></div></div>

<p>커맨드 입력 후 <code class="language-plaintext highlighter-rouge">scope</code>라는 이미지가 실행된다.</p>

<p>ColO-RAN의 경우, RIC과 ColO-RAN 컨테이너 간 메시지들이 직접적으로 통신되기 위해 Network Address Translation(NAT) 규칙들을 구성하는 것이 필수적이다.</p>

<p>위에서 설명한 과정들을 자동화하기 위해 저자는 스크립트 파일들을 오픈 소스로 제공하고 있다. 스크립트 파일들은 아래와 같은 과정들을 포함한다.</p>
<ol>
  <li>컨테이너에게 정확한 radio interface 전달</li>
  <li>컨테이너에게 적절한 권한 부여</li>
  <li>호스트 머신의 NAT 규칙들 세팅</li>
  <li>Importing 된 이미지로부터 OpenRAN Gym LXC 컨테이너들 시작</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Listing 9</span>
./start-lxc-scope.sh testbed usrp-type <span class="o">[</span>flash]
</code></pre></div></div>
<p class="note">SCOPE LXC 컨테이너를 생성, 세팅, 시작하는 스크립트 파일을 실행하는 커맨드</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Listing 10</span>
./start-lxc-ric.sh
</code></pre></div></div>
<p class="note"><code class="language-plaintext highlighter-rouge">Listing 6</code>에서 생성된 이미지로부터 SCOPE LXC 컨테이너를 생성, 세팅, 실행하는 커맨드</p>

<h2 id="27-experimental-results">2.7 Experimental Results</h2>

<p>이 섹션에서는 작동중인 HetNet에서 작동죽인 OpenRAN Gym에서 실행한 시뮬레이션 결과들을 설명한다.</p>

<p>공정한 비교를 위해 각 테스트베드마다 1개의 cellular base station과 3개의 UE, 1개의 near-RT RIC 노드만을 가지고 시뮬레이션을 진행하였다.</p>

<p>iPerf3 툴에 의해 생성된 Downlink User Datagram Protocol(UDP) 트래픽을 이용하여 네트워크 성능을 평가하였다.</p>

<h3 id="27a-results">2.7.A Results</h3>

<p><img src="/assets/img/blog/OpenRANgym/article/Figure.6,7.png" alt="Figure 6,7" />
<img src="/assets/img/blog/OpenRANgym/article/Table 2.png" alt="Table 2" /></p>

<p>Figure 6과 7은 각 network slicing마다 RBG들이 다르게 할당되었을 때 전체 네트워크 throughput을 보여준다. 시뮬레이션 결과를 통해 다양한 테스트베드에서 throughput이 다를지라도, 전체적인 추세는 비슷하다는 것을 알 수 있다.</p>

<p>아래의 그림은 SCOPE를 통해 ColO-RAN near-RT RIC이 소프트웨어화 된 RAN을 control하는 것을 구현한 결과이다.
<img src="/assets/img/blog/OpenRANgym/article/Figure 8.png" alt="Figure 8" /></p>

<p>Baseline은 RIC에 의한 제어가 없을 때로 설정하였고, 150초마다 xApp이 특정 network slice를 선호하도록 설정하였다.</p>

<p>O-RAN RAN slicing SM에 의해 각 slice에만 할당된 RBG의 수를 런타임에 재구성하여 수행되며, 해당 slice에 속한 사용자의 transmission을 예약할 수 있다.</p>

<h2 id="28-conclusions">2.8 Conclusions</h2>

<p>본 논문에서는 최초의 publicly-available research 픒랫폼인 OpenRAN Gym을 소개하였다. 또한 다양한 스케일의 테스트베드에서 시뮬레이션을 진행하며 결과를 제시하였고, 많은 연구자들의 사용을 권장한다.</p>

<h1 id="3-take-away">3. Take Away</h1>

<ul>
  <li>OpenRAN Gym 사용 커맨드를 꼭 기억하여 MaveRIC 시뮬레이터에 사용할 것</li>
  <li>Container 환경에서 시뮬레이션이 진행된다는 것을 기억</li>
  <li>HetNet 환경의 에뮬리에션이 가능함</li>
</ul>]]></content><author><name>Geon Kim</name><email>gun@khu.ac.kr</email></author><category term="paper" /><category term="ieee" /><category term="o-ran" /><summary type="html"><![CDATA[**Authors**: Leonardo Bonati, Michele Polese, Salvatore D'Oro, Stefano Basagni, Tommaso Melodia]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/OpenRANgym/thumbnail.jpeg" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/OpenRANgym/thumbnail.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>